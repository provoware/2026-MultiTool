<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Songtext-Workbench Plus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="assets/styles.css" />
  <script src="assets/ui.js"></script>
</head>
<body data-page="songtext" data-theme="dark" aria-label="Songtext-Workbench" data-font-size="base">
<div class="app-root">
  <header class="app-header" role="banner">
    <div class="app-title-group">
      <div class="app-logo" aria-hidden="true"></div>
      <div>
        <div class="app-title">Songtext-Workbench</div>
        <div class="app-subtitle">Brainstorming & Struktur f√ºr Lyrics</div>
      </div>
      <span class="badge" aria-label="Autosave und Dateiformate">Autosave 5 min ¬∑ JSON/TXT ¬∑ Backup</span>
    </div>
    <div class="header-right" aria-label="Status und Einstellungen">
      <div class="status-pill" aria-live="polite" role="status" aria-atomic="true">
        <span class="status-dot" aria-hidden="true"></span>
        <span id="statusText">Bereit</span>
      </div>
      <div id="clockBadge" class="badge" aria-label="Datum und Uhrzeit">--:--</div>
      <div class="header-controls">
        <select id="themeSelect" class="header-select" aria-label="Farbschema w√§hlen" data-theme-select>
          <option value="dark">Dark</option>
          <option value="light">Light</option>
          <option value="solar">Solar</option>
          <option value="contrast">High Contrast</option>
        </select>
        <select id="fontSizeSelect" class="header-select" aria-label="Grundschriftgr√∂√üe w√§hlen" data-font-select>
          <option value="small">A-</option>
          <option value="base" selected>A</option>
          <option value="large">A+</option>
        </select>
        <button class="icon-button" id="toggleLeftSidebarBtn" title="Linke Sidebar ein- oder ausblenden" aria-label="Linke Sidebar ein- oder ausblenden">
          <span class="icon">üß±</span><span>Links</span>
        </button>
        <button class="icon-button" id="toggleRightSidebarBtn" title="Rechte Sidebar ein- oder ausblenden" aria-label="Rechte Sidebar ein- oder ausblenden">
          <span class="icon">üìÅ</span><span>Rechts</span>
        </button>
        <button class="icon-button" id="backupExportBtn" title="Backup exportieren" aria-label="Backup exportieren">
          <span class="icon">üíæ</span><span>Backup</span>
        </button>
        <button class="icon-button" id="backupImportBtn" title="Backup importieren" aria-label="Backup importieren">
          <span class="icon">üì•</span><span>Import</span>
        </button>
        <input type="file" id="backupImportFile" class="hidden-input" accept=".json" />
      </div>
    </div>
  </header>

  <div class="app-layout">
    <aside class="sidebar sidebar-left" id="leftSidebar" role="complementary" aria-label="Bereiche und Templates">
      <div class="sidebar-header">
        <span class="sidebar-title">Bereiche & Templates</span>
        <button class="btn btn-ghost" id="addSectionBtn" title="Neuen Songbereich hinzuf√ºgen">+ Bereich</button>
      </div>

      <div class="sidebar-section">
        <h3>Song-Bereiche</h3>
        <ul id="sectionList" class="song-list" aria-label="Liste der Songbereiche"></ul>
      </div>

      <div class="sidebar-section">
        <h3>Templates</h3>
        <div class="field-group" data-field-group>
          <div class="field-label">
            <span>Template</span>
            <span class="meta">Strukturen speichern & laden</span>
          </div>
          <div class="field-content">
            <div class="field-row">
              <input type="text" id="templateNameInput" placeholder="Template-Name (z.B. Pop-Standard)" aria-label="Template-Name" />
              <button class="btn btn-primary" id="saveTemplateBtn">Speichern</button>
            </div>
            <textarea id="templateContentInput" class="text-zoom-area" placeholder="z.B. Intro:\nStrophe 1:\nRefrain: ..." aria-label="Template-Inhalt"></textarea>
            <div class="field-row">
              <select id="templateSelect" aria-label="Template ausw√§hlen">
                <option value="">Template w√§hlen‚Ä¶</option>
              </select>
              <button class="btn" id="applyTemplateToSongBtn">In Song einf√ºgen</button>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Hilfe kurz</h3>
        <div class="help-text">
          <p><b>Bereiche</b> wie <i>Intro:</i>, <i>Strophe:</i>, <i>Bridge:</i> frei anlegen. Templates speichern komplette Song-Strukturen ‚Äì ein Bereich pro Zeile.</p>
          <p>Per Klick kannst du ein Template in den aktuellen Song √ºbernehmen. Alle Eingaben sind per Tastatur und Screenreader zug√§nglich.</p>
        </div>
      </div>
    </aside>

    <main class="main" role="main" aria-label="Hauptarbeitsbereich">
      <section class="column col-1" aria-label="Song-Erarbeitung">
        <div class="column-header">
          <div>
            <div class="column-header-title">Song-Erarbeitung</div>
            <div class="column-header-sub">Bereiche, Text, Titel & Workflow</div>
          </div>
          <button class="btn btn-primary" id="newSongBtn">‚ûï Neuer Song</button>
        </div>
        <div class="column-body">
          <div class="scroll-section">
            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Song-Titel</span>
                <span class="meta">wird Dateiname</span>
              </div>
              <div class="field-content">
                <input type="text" id="songTitleInput" placeholder="Arbeitstitel eingeben‚Ä¶" aria-label="Songtitel" />
              </div>
            </div>

            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Bereich hinzuf√ºgen</span>
                <span class="meta">z.B. Intro:, Strophe 1:, Bridge:</span>
              </div>
              <div class="field-content">
                <div class="field-row">
                  <input type="text" id="sectionNameInput" placeholder="z.B. Strophe 1:" aria-label="Name des neuen Bereichs" />
                  <button class="btn" id="insertSectionBtn">In Song einf√ºgen</button>
                </div>
              </div>
            </div>

            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Songtext-Arbeitsbereich</span>
                <span class="meta">Strg+S speichert</span>
              </div>
              <div class="field-content">
                <textarea id="songEditor" class="text-zoom-area" aria-label="Songtext bearbeiten" placeholder="Hier deinen Songtext mit Bereichen ausarbeiten‚Ä¶"></textarea>
              </div>
            </div>

            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Schnellaktionen</span>
                <span class="meta">Genres & Export</span>
              </div>
              <div class="field-content">
                <div class="field-row">
                  <button class="btn" id="insertGenresIntoSongBtn">Genres/Stimmungen in Song einf√ºgen</button>
                  <button class="btn" id="exportSongTxtBtn">als TXT exportieren</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <div class="col-resizer" data-resizer="1" aria-hidden="true"></div>

      <section class="column col-2" aria-label="Zusatzinfos und Profile">
        <div class="column-header">
          <div>
            <div class="column-header-title">Zusatzinfos & Profile</div>
            <div class="column-header-sub">Genres, Tags, Hashtags, Profile & Zufall</div>
          </div>
        </div>
        <div class="column-body">
          <div class="scroll-section scroll-half">
            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Genres</span>
                <span class="meta">Kommagetrennt, Duplikate werden ignoriert</span>
              </div>
              <div class="field-content">
                <textarea id="genresInput" class="text-zoom-area" aria-label="Genres" placeholder="Techno, House, Ambient, ..."></textarea>
              </div>
            </div>

            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Tags & Hashtags</span>
                <span class="meta">z.B. emotional, #nightdrive</span>
              </div>
              <div class="field-content">
                <textarea id="tagsInput" class="text-zoom-area" aria-label="Tags und Hashtags" placeholder="emotional, #nightdrive, story-telling, ..."></textarea>
              </div>
            </div>

            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Cover-Ideen & Sonstiges</span>
                <span class="meta">Freie Notizen</span>
              </div>
              <div class="field-content">
                <textarea id="coverIdeasInput" class="text-zoom-area" aria-label="Coverideen und Sonstiges" placeholder="Cover-Motive, Farben, Story, ..."></textarea>
              </div>
            </div>
          </div>

          <div class="scroll-section divider-top">
            <div class="tab-bar" role="tablist">
              <button class="tab active" data-tab="profilesTab" role="tab" aria-selected="true">Profile</button>
              <button class="tab" data-tab="archiveTab" role="tab" aria-selected="false">Archiv</button>
            </div>

            <div id="profilesTab" class="tab-content active" role="tabpanel">
              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Profil erstellen</span>
                  <span class="meta">z.B. Techno, H√∂rspiel ‚Ä¶</span>
                </div>
                <div class="field-content">
                  <input type="text" id="profileNameInput" placeholder="Profilname" aria-label="Profilname" />
                </div>
              </div>

              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Genres (Profil)</span>
                  <span class="meta">Kommagetrennt</span>
                </div>
                <div class="field-content">
                  <textarea id="profileGenresInput" class="text-zoom-area" aria-label="Profil-Genres" placeholder="Techno, Dub Techno, Detroit, ..."></textarea>
                </div>
              </div>

              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Stimmung</span>
                  <span class="meta">Kommagetrennt</span>
                </div>
                <div class="field-content">
                  <textarea id="profileMoodsInput" class="text-zoom-area" aria-label="Profil-Stimmungen" placeholder="dunkel, treibend, hypnotisch, ..."></textarea>
                </div>
              </div>

              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Besondere Effekte / Stil</span>
                  <span class="meta">Kommagetrennt</span>
                </div>
                <div class="field-content">
                  <textarea id="profileEffectsInput" class="text-zoom-area" aria-label="Besondere Effekte oder Stil" placeholder="Fieldrecordings, verzerrte Vocals, ..."></textarea>
                </div>
              </div>

              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Profil-Aktionen</span>
                  <span class="meta">Speichern & Import/Export</span>
                </div>
                <div class="field-content">
                  <div class="field-row">
                    <button class="btn btn-primary" id="saveProfileBtn">Profil speichern</button>
                    <button class="btn" id="exportProfilesBtn">Profile exportieren (JSON)</button>
                    <button class="btn" id="importProfilesBtn">Importieren</button>
                    <input type="file" id="importProfilesFile" class="hidden-input" accept=".json" />
                  </div>
                </div>
              </div>

              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Profile im Archiv</span>
                  <span class="meta" id="profileCountMeta">0 Profile</span>
                </div>
                <div class="field-content">
                  <div class="profiles-list" id="profilesList"></div>
                </div>
              </div>

              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Zufallsgenerator</span>
                  <span class="meta">ohne Duplikate ¬∑ log-persistent</span>
                </div>
                <div class="field-content">
                  <div class="field-row">
                    <select id="profileSelectForRandom" aria-label="Profil f√ºr Zufallsgenerator w√§hlen">
                      <option value="">Profil w√§hlen‚Ä¶</option>
                    </select>
                    <select id="randomAmountSelect" aria-label="Anzahl der zuf√§lligen Eintr√§ge w√§hlen">
                      <option value="4">4</option>
                      <option value="8">8</option>
                      <option value="12">12</option>
                      <option value="16">16</option>
                      <option value="20">20</option>
                    </select>
                    <button class="btn btn-primary" id="generateRandomBtn">üé≤ Genres</button>
                  </div>
                </div>
              </div>

              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Zufalls-Ergebnis</span>
                  <span class="meta">wird in Genres-Feld √ºbernommen</span>
                </div>
                <div class="field-content">
                  <textarea id="randomResultOutput" class="text-zoom-area" readonly aria-label="Zufallsausgabe"></textarea>
                </div>
              </div>
            </div>

            <div id="archiveTab" class="tab-content" role="tabpanel">
              <div class="field-group" data-field-group>
                <div class="field-label">
                  <span>Archivierte Begriffe</span>
                  <span class="meta" id="archiveStatsMeta">0 Eintr√§ge</span>
                </div>
                <div class="field-content">
                  <div class="archive-list" id="archiveList"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <div class="col-resizer" data-resizer="2" aria-hidden="true"></div>

      <section class="column col-3" aria-label="Vorschau und Dashboard">
        <div class="column-header">
          <div>
            <div class="column-header-title">Vorschau & Dashboard</div>
            <div class="column-header-sub">Gesamttext, Statistiken & Speicher</div>
          </div>
          <button class="btn" id="refreshPreviewBtn">üîÑ Aktualisieren</button>
        </div>
        <div class="column-body">
          <div class="scroll-section">
            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Song-Vorschau</span>
                <span class="meta">Nur Anzeige ‚Äì bearbeitet wird links</span>
              </div>
              <div class="field-content">
                <div id="songPreview" class="preview-text text-zoom-area" aria-label="Songvorschau"></div>
              </div>
            </div>

            <div class="stats-grid" aria-label="Statistik des Songs">
              <div class="stat-card">
                <div class="stat-label">Zeichen</div>
                <div class="stat-value" id="charCountStat">0</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">W√∂rter</div>
                <div class="stat-value" id="wordCountStat">0</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">Abschnitte</div>
                <div class="stat-value" id="sectionCountStat">0</div>
              </div>
            </div>

            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Song-Archiv-Steuerung</span>
                <span class="meta">Buttons & Dialoge</span>
              </div>
              <div class="field-content">
                <div class="field-row">
                  <button class="btn btn-primary" id="saveSongToArchiveBtn">üíæ Song im Archiv speichern</button>
                  <button class="btn" id="duplicateSongBtn">üìÑ Duplizieren</button>
                  <button class="btn btn-danger" id="deleteSongBtn">üóë L√∂schen</button>
                </div>
              </div>
            </div>

            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>Song-Archiv (Projekt)</span>
                <span class="meta" id="songArchiveCountMeta">0 Songs</span>
              </div>
              <div class="field-content">
                <ul class="song-list" id="songArchiveList" aria-label="Gespeicherte Songs"></ul>
              </div>
            </div>

            <div class="field-group" data-field-group>
              <div class="field-label">
                <span>System-Log</span>
                <span class="meta">Ereignisse in Echtzeit</span>
              </div>
              <div class="field-content">
                <div class="log-panel" id="logPanel" aria-live="polite"></div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <aside class="sidebar sidebar-right" id="rightSidebar" role="complementary" aria-label="Projekt-Songs">
      <div class="sidebar-header">
        <span class="sidebar-title">Projekt-Songs</span>
        <span class="badge-mini" id="projectSongCount">0</span>
      </div>

      <div class="sidebar-section">
        <h3>Songliste</h3>
        <ul id="projectSongList" class="song-list" aria-label="Songliste im Projekt"></ul>
      </div>

      <div class="sidebar-section">
        <h3>Editieren</h3>
        <div class="field-group" data-field-group>
          <div class="field-label">
            <span>Aktiver Song</span>
          </div>
          <div class="field-content">
            <input type="text" id="activeSongFileName" readonly aria-label="Aktiver Dateiname" />
          </div>
        </div>
        <div class="field-group" data-field-group>
          <div class="field-label">
            <span>Datei-Aktionen</span>
          </div>
          <div class="field-content">
            <div class="field-row">
              <button class="btn" id="renameSongBtn">Umbenennen</button>
              <button class="btn btn-danger" id="removeFromProjectBtn">Aus Projekt entfernen</button>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar-section">
        <h3>Hinweis</h3>
        <div class="help-text">
          Songs, Profile und Einstellungen werden lokal (Browser) als JSON gesichert. Mit den Backup-Funktionen kannst du alles exportieren und sp√§ter wieder importieren.
        </div>
      </div>
    </aside>
  </div>
</div>

<div class="toast" id="toast" role="status" aria-live="polite">
  <span class="icon">‚úÖ</span>
  <span id="toastMessage">Gespeichert</span>
</div>

<script>
  const STORAGE_KEY = "songworkbench_state_v2";

  const initialState = {
    songs: {},
    currentSongId: null,
    sections: [],
    templates: {},
    profiles: {},
    archiveTerms: {},
    randomLogs: [],
    settings: {
      theme: "dark",
      fontSize: "base",
      autosaveMinutes: 5,
      uiZoom: 1,
      textZoom: 1
    }
  };

  let appState = clone(initialState);
  let autosaveTimer = null;

  function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function handleError(err, context) {
    console.error("Fehler in Kontext:", context, err);
    showToast("Fehler: " + context + " ‚Äì versuche Wiederherstellung", true);
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        appState = Object.assign(clone(initialState), parsed);
        renderAll();
        showToast("Letzten bekannten Stand geladen.", false);
      }
    } catch (e) {
      console.error("Recovery failed:", e);
      showToast("Recovery fehlgeschlagen ‚Äì neuer sauberer Zustand.", true);
      appState = clone(initialState);
      renderAll();
      saveState();
    }
  }

  function saveState() {
    try {
      const toSave = clone(appState);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
      logEvent("State gespeichert.");
    } catch (err) {
      handleError(err, "saveState");
    }
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        appState = clone(initialState);
        return;
      }
      const parsed = JSON.parse(raw);
      appState = Object.assign(clone(initialState), parsed);
    } catch (err) {
      handleError(err, "loadState");
    }
  }

  function showToast(message, isError) {
    const toast = document.getElementById("toast");
    const msgEl = document.getElementById("toastMessage");
    const iconEl = toast.querySelector(".icon");
    msgEl.textContent = message;
    iconEl.textContent = isError ? "‚ö†Ô∏è" : "‚úÖ";
    toast.classList.add("show");
    setTimeout(() => toast.classList.remove("show"), 2600);
  }

  function logEvent(text) {
    const now = new Date();
    const timeStr = now.toLocaleTimeString();
    const logPanel = document.getElementById("logPanel");
    if (!logPanel) return;
    const entry = document.createElement("div");
    entry.className = "log-entry";
    entry.innerHTML = "<span class=\"time\">" + timeStr + "</span> ‚Äì " + text;
    logPanel.prepend(entry);
  }

  function updateClock() {
    const el = document.getElementById("clockBadge");
    const now = new Date();
    const timeStr = now.toLocaleTimeString("de-DE", { hour: "2-digit", minute: "2-digit" });
    const dateStr = now.toLocaleDateString("de-DE");
    if (el) el.textContent = dateStr + " ¬∑ " + timeStr;
  }

  function setStatus(text) {
    const el = document.getElementById("statusText");
    if (el) el.textContent = text;
  }

  function debounce(fn, delay) {
    let t;
    return (...args) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...args), delay);
    };
  }

  function renderAll() {
    applySettingsToDOM();
    renderSectionsSidebar();
    renderTemplates();
    renderProfiles();
    renderArchiveTerms();
    renderCurrentSong();
    renderSongArchive();
    renderStats();
    renderPreview();
    renderProjectSidebar();
    enhanceFieldGroups();
  }

  function applySettingsToDOM() {
    const theme = appState.settings.theme || "dark";
    SharedUI.applyTheme(theme);
    document.body.setAttribute("data-theme", theme);
    document.body.setAttribute("data-font-size", appState.settings.fontSize || "base");
    document.documentElement.style.setProperty("--ui-zoom", appState.settings.uiZoom || 1);
    document.documentElement.style.setProperty("--text-zoom", appState.settings.textZoom || 1);

    document.getElementById("themeSelect").value = theme;
    document.getElementById("fontSizeSelect").value = appState.settings.fontSize || "base";
  }

  function renderSectionsSidebar() {
    const list = document.getElementById("sectionList");
    list.innerHTML = "";
    appState.sections.forEach((name, index) => {
      const li = document.createElement("li");
      li.className = "song-list-item";
      li.innerHTML = "<span class=\"song-list-item-title\">" + name + "</span>" +
                     "<span class=\"song-list-item-meta\">#" + (index + 1) + "</span>";
      li.addEventListener("click", () => {
        insertTextIntoSongEditor(name + "\n");
      });
      list.appendChild(li);
    });
  }

  function renderTemplates() {
    const select = document.getElementById("templateSelect");
    select.innerHTML = '<option value="">Template w√§hlen‚Ä¶</option>';
    Object.keys(appState.templates).forEach((name) => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      select.appendChild(opt);
    });
  }

  function renderProfiles() {
    const profilesList = document.getElementById("profilesList");
    const profileSelect = document.getElementById("profileSelectForRandom");
    profilesList.innerHTML = "";
    profileSelect.innerHTML = '<option value="">Profil w√§hlen‚Ä¶</option>';

    const names = Object.keys(appState.profiles).sort();
    document.getElementById("profileCountMeta").textContent = names.length + " Profile";

    names.forEach((name) => {
      const p = appState.profiles[name];
      const row = document.createElement("div");
      row.className = "profiles-list-row";
      const totalCount = (p.genres.length + p.moods.length + p.effects.length);
      row.innerHTML = "<span class=\"profiles-list-row-title\">" + name + "</span>" +
                      "<span>" + totalCount + " Eintr√§ge</span>";
      profilesList.appendChild(row);

      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name + " (" + totalCount + ")";
      profileSelect.appendChild(opt);
    });
  }

  function renderArchiveTerms() {
    const archiveList = document.getElementById("archiveList");
    const statsMeta = document.getElementById("archiveStatsMeta");
    archiveList.innerHTML = "";

    const entries = Object.entries(appState.archiveTerms);
    statsMeta.textContent = entries.length + " Eintr√§ge";

    entries
      .sort((a, b) => b[1].count - a[1].count)
      .forEach(([term, info]) => {
        const row = document.createElement("div");
        row.className = "archive-list-row";
        row.innerHTML = "<span>" + term + "</span>" +
                        "<span>" + info.type + " ¬∑ x" + info.count + "</span>";
        archiveList.appendChild(row);
      });
  }

  function renderCurrentSong() {
    const song = appState.currentSongId ? appState.songs[appState.currentSongId] : null;
    const titleInput = document.getElementById("songTitleInput");
    const editor = document.getElementById("songEditor");
    const genresInput = document.getElementById("genresInput");
    const tagsInput = document.getElementById("tagsInput");
    const coverIdeasInput = document.getElementById("coverIdeasInput");
    const fileNameDisplay = document.getElementById("activeSongFileName");

    if (!song) {
      titleInput.value = "";
      editor.value = "";
      genresInput.value = "";
      tagsInput.value = "";
      coverIdeasInput.value = "";
      fileNameDisplay.value = "";
      return;
    }

    titleInput.value = song.title || "";
    editor.value = song.text || "";
    genresInput.value = (song.genres || []).join(", ");
    tagsInput.value = (song.tags || []).join(", ");
    coverIdeasInput.value = song.coverIdeas || "";
    fileNameDisplay.value = createSongFileName(song.title || "");
  }

  function renderSongArchive() {
    const list = document.getElementById("songArchiveList");
    const countMeta = document.getElementById("songArchiveCountMeta");
    list.innerHTML = "";

    const entries = Object.values(appState.songs)
      .sort((a, b) => (a.title || "").localeCompare(b.title || ""));

    countMeta.textContent = entries.length + " Songs";

    entries.forEach((song) => {
      const li = document.createElement("li");
      li.className = "song-list-item" + (song.id === appState.currentSongId ? " active" : "");
      const title = song.title || "(ohne Titel)";
      li.innerHTML = "<div class=\"song-list-item-title\" title=\"" + title + "\">" + title + "</div>" +
                     "<div class=\"song-list-item-meta\">" + (song.genres || []).length + " Genres</div>";
      li.addEventListener("click", () => {
        appState.currentSongId = song.id;
        setStatus("Song geladen: " + (song.title || ""));
        renderAll();
      });
      list.appendChild(li);
    });
  }

  function renderProjectSidebar() {
    const list = document.getElementById("projectSongList");
    const countEl = document.getElementById("projectSongCount");
    list.innerHTML = "";

    const entries = Object.values(appState.songs)
      .sort((a, b) => (a.title || "").localeCompare(b.title || ""));

    countEl.textContent = entries.length;

    entries.forEach((song) => {
      const li = document.createElement("li");
      li.className = "song-list-item" + (song.id === appState.currentSongId ? " active" : "");
      const title = song.title || "(ohne Titel)";
      li.innerHTML = "<span class=\"song-list-item-title\" title=\"" + title + "\">" + title + "</span>" +
                     "<span class=\"song-list-item-meta\">" + (song.updatedAt ? new Date(song.updatedAt).toLocaleDateString("de-DE") : "") + "</span>";
      li.addEventListener("click", () => {
        appState.currentSongId = song.id;
        renderAll();
      });
      list.appendChild(li);
    });
  }

  function renderStats() {
    const song = appState.currentSongId ? appState.songs[appState.currentSongId] : null;
    const text = song && song.text ? song.text : "";
    const chars = text.length;
    const words = text.trim() ? text.trim().split(/\s+/).length : 0;
    const sections = (text.match(/:.*/g) || []).length;

    document.getElementById("charCountStat").textContent = chars;
    document.getElementById("wordCountStat").textContent = words;
    document.getElementById("sectionCountStat").textContent = sections;
  }

  function renderPreview() {
    const song = appState.currentSongId ? appState.songs[appState.currentSongId] : null;
    const preview = document.getElementById("songPreview");
    if (!song) {
      preview.textContent = "";
      return;
    }
    const header = song.title ? "# " + song.title + "\n\n" : "";
    const metaParts = [];
    if (song.genres && song.genres.length) metaParts.push("Genres: " + song.genres.join(", "));
    if (song.tags && song.tags.length) metaParts.push("Tags: " + song.tags.join(", "));
    const meta = metaParts.length ? metaParts.join(" | ") + "\n\n" : "";
    preview.textContent = header + meta + (song.text || "");
  }

  function ensureCurrentSong() {
    if (appState.currentSongId && appState.songs[appState.currentSongId]) return;

    const id = "song_" + Date.now();
    appState.currentSongId = id;
    appState.songs[id] = {
      id,
      title: "",
      text: "",
      genres: [],
      tags: [],
      coverIdeas: "",
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
  }

  function createSongFileName(title) {
    const safe = (title || "unbenannter-song")
      .toLowerCase()
      .replace(/[^a-z0-9]+/gi, "-")
      .replace(/^-+|-+$/g, "");
    return safe + ".txt";
  }

  function splitAndArchive(text, type) {
    const items = text
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s.length > 0);

    const unique = [];
    const seen = new Set();

    items.forEach((item) => {
      const key = item.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(item);
        if (!appState.archiveTerms[item]) {
          appState.archiveTerms[item] = { type, count: 1 };
        } else {
          appState.archiveTerms[item].count += 1;
        }
      }
    });

    return unique;
  }

  function updateCurrentSongFromInputs() {
    ensureCurrentSong();
    const song = appState.songs[appState.currentSongId];
    const title = document.getElementById("songTitleInput").value.trim();
    const text = document.getElementById("songEditor").value;
    const genresRaw = document.getElementById("genresInput").value;
    const tagsRaw = document.getElementById("tagsInput").value;
    const coverIdeas = document.getElementById("coverIdeasInput").value;

    song.title = title;
    song.text = text;
    song.genres = splitAndArchive(genresRaw, "genre");
    song.tags = splitAndArchive(tagsRaw, "tag");
    song.coverIdeas = coverIdeas;
    song.updatedAt = new Date().toISOString();

    renderStats();
    renderPreview();
    renderSongArchive();
    renderProjectSidebar();
  }

  function insertTextIntoSongEditor(text) {
    const editor = document.getElementById("songEditor");
    const start = editor.selectionStart;
    const end = editor.selectionEnd;
    const val = editor.value;
    editor.value = val.slice(0, start) + text + val.slice(end);
    editor.focus();
    const newPos = start + text.length;
    editor.selectionStart = editor.selectionEnd = newPos;
    updateCurrentSongFromInputs();
  }

  function setupAutosave() {
    if (autosaveTimer) clearInterval(autosaveTimer);
    const minutes = appState.settings.autosaveMinutes || 5;
    autosaveTimer = setInterval(() => {
      updateCurrentSongFromInputs();
      saveState();
      showToast("Autosave abgeschlossen", false);
    }, minutes * 60 * 1000);
  }

  function exportCurrentSongAsTxt() {
    ensureCurrentSong();
    const song = appState.songs[appState.currentSongId];
    const header = song.title ? song.title + "\n\n" : "";
    const metaParts = [];
    if (song.genres && song.genres.length) metaParts.push("Genres: " + song.genres.join(", "));
    if (song.tags && song.tags.length) metaParts.push("Tags: " + song.tags.join(", "));
    const meta = metaParts.length ? metaParts.join(" | ") + "\n\n" : "";
    const content = header + meta + (song.text || "");

    const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = createSongFileName(song.title);
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    logEvent("Song als TXT exportiert.");
  }

  function exportProfilesAsJSON() {
    const blob = new Blob([JSON.stringify(appState.profiles, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "song_profiles.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    logEvent("Profile als JSON exportiert.");
  }

  function importProfilesFromFile(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const json = JSON.parse(e.target.result);
        appState.profiles = Object.assign({}, appState.profiles, json);
        renderProfiles();
        saveState();
        showToast("Profile importiert.", false);
      } catch (err) {
        handleError(err, "importProfilesFromFile");
      }
    };
    reader.readAsText(file, "utf-8");
  }

  function exportBackup() {
    try {
      const blob = new Blob([JSON.stringify(appState, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "songworkbench_backup_" + new Date().toISOString().replace(/[:.]/g, "-") + ".json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      logEvent("Vollst√§ndiges Backup exportiert.");
      showToast("Backup exportiert.", false);
    } catch (err) {
      handleError(err, "exportBackup");
    }
  }

  function importBackup(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const json = JSON.parse(e.target.result);
        appState = Object.assign(clone(initialState), json);
        renderAll();
        saveState();
        showToast("Backup importiert.", false);
        logEvent("Backup importiert.");
      } catch (err) {
        handleError(err, "importBackup");
      }
    };
    reader.readAsText(file, "utf-8");
  }

  function generateRandomGenres() {
    const profileSelect = document.getElementById("profileSelectForRandom");
    const amountSelect = document.getElementById("randomAmountSelect");
    const profileName = profileSelect.value;
    const amount = parseInt(amountSelect.value, 10);

    const profile = appState.profiles[profileName] || { genres: [], moods: [], effects: [] };
    const all = [
      ...(profile.genres || []),
      ...(profile.moods || []),
      ...(profile.effects || [])
    ];

    Object.keys(appState.archiveTerms).forEach((term) => {
      all.push(term);
    });

    const unique = Array.from(new Set(all));
    if (!unique.length) {
      showToast("Keine Eintr√§ge f√ºr Zufallsgenerator vorhanden.", true);
      return;
    }

    const result = [];
    const pool = unique.slice();

    while (result.length < amount && pool.length > 0) {
      const idx = Math.floor(Math.random() * pool.length);
      result.push(pool[idx]);
      pool.splice(idx, 1);
    }

    const text = result.join(", ");
    const out = document.getElementById("randomResultOutput");
    out.value = text;

    const genresInput = document.getElementById("genresInput");
    genresInput.value = text;
    updateCurrentSongFromInputs();

    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).catch(() => {});
    }

    const logEntry = {
      when: new Date().toISOString(),
      profile: profileName || null,
      amount,
      result
    };
    appState.randomLogs.push(logEntry);
    logEvent("Genres-Zufallsgenerator ausgef√ºhrt (" + amount + ").");
    saveState();
    showToast("Zuf√§llige Genres generiert & kopiert.", false);
  }

  function createNewSong() {
    const id = "song_" + Date.now();
    const now = new Date().toISOString();
    appState.songs[id] = {
      id,
      title: "",
      text: "",
      genres: [],
      tags: [],
      coverIdeas: "",
      createdAt: now,
      updatedAt: now
    };
    appState.currentSongId = id;
    renderAll();
    saveState();
    logEvent("Neuer Song erstellt.");
  }

  function duplicateCurrentSong() {
    if (!appState.currentSongId) return;
    const original = appState.songs[appState.currentSongId];
    const id = "song_" + Date.now();
    const now = new Date().toISOString();
    appState.songs[id] = Object.assign(clone(original), {
      id,
      title: (original.title || "") + " (Kopie)",
      createdAt: now,
      updatedAt: now
    });
    appState.currentSongId = id;
    renderAll();
    saveState();
    logEvent("Song dupliziert.");
  }

  function deleteCurrentSong() {
    if (!appState.currentSongId) return;
    const song = appState.songs[appState.currentSongId];
    const title = song.title || "(ohne Titel)";
    if (!confirm('Song "' + title + '" wirklich l√∂schen?')) return;
    delete appState.songs[appState.currentSongId];
    appState.currentSongId = Object.keys(appState.songs)[0] || null;
    renderAll();
    saveState();
    logEvent("Song gel√∂scht: " + title);
  }

  function renameCurrentSong() {
    if (!appState.currentSongId) return;
    const song = appState.songs[appState.currentSongId];
    const newTitle = prompt("Neuer Titel f√ºr Song:", song.title || "");
    if (newTitle === null) return;
    const trimmed = newTitle.trim();
    if (!trimmed) return;
    song.title = trimmed;
    song.updatedAt = new Date().toISOString();
    renderAll();
    saveState();
    logEvent("Song umbenannt zu: " + trimmed);
  }

  function removeCurrentSongFromProject() {
    deleteCurrentSong();
  }

  function saveSongToArchive() {
    updateCurrentSongFromInputs();
    saveState();
    showToast("Song im Archiv gespeichert.", false);
  }

  function addSectionName() {
    const input = document.getElementById("sectionNameInput");
    const name = input.value.trim();
    if (!name) return;
    if (!appState.sections.includes(name)) {
      appState.sections.push(name);
      renderSectionsSidebar();
      saveState();
      logEvent("Bereich hinzugef√ºgt: " + name);
    }
    insertTextIntoSongEditor(name + "\n");
    input.value = "";
  }

  function addSectionSidebar() {
    const name = prompt("Name des neuen Bereichs (mit Doppelpunkt endend, z.B. Strophe 1:)", "Strophe 1:");
    if (!name) return;
    const n = name.trim();
    if (!n) return;
    if (!appState.sections.includes(n)) {
      appState.sections.push(n);
      renderSectionsSidebar();
      saveState();
    }
  }

  function saveTemplate() {
    const nameInput = document.getElementById("templateNameInput");
    const contentInput = document.getElementById("templateContentInput");
    const name = nameInput.value.trim();
    const content = contentInput.value.trim();
    if (!name || !content) {
      showToast("Template-Name und Inhalt erforderlich.", true);
      return;
    }
    appState.templates[name] = content;
    renderTemplates();
    saveState();
    showToast("Template gespeichert.", false);
  }

  function applyTemplateToSong() {
    const select = document.getElementById("templateSelect");
    const name = select.value;
    if (!name) return;
    const content = appState.templates[name];
    if (!content) return;
    insertTextIntoSongEditor(content + "\n");
    logEvent("Template eingef√ºgt: " + name);
  }

  function saveProfile() {
    const name = document.getElementById("profileNameInput").value.trim();
    if (!name) {
      showToast("Profilname erforderlich.", true);
      return;
    }
    const genres = splitToUniqueList(document.getElementById("profileGenresInput").value);
    const moods = splitToUniqueList(document.getElementById("profileMoodsInput").value);
    const effects = splitToUniqueList(document.getElementById("profileEffectsInput").value);

    appState.profiles[name] = { genres, moods, effects };
    renderProfiles();
    saveState();
    showToast("Profil gespeichert.", false);
    logEvent("Profil gespeichert: " + name);
  }

  function splitToUniqueList(text) {
    const arr = text.split(",").map((s) => s.trim()).filter(Boolean);
    return Array.from(new Set(arr));
  }

  function setupTabs() {
    const tabs = document.querySelectorAll(".tab");
    tabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        const tabId = tab.dataset.tab;
        document.querySelectorAll(".tab").forEach((t) => {
          t.classList.remove("active");
          t.setAttribute("aria-selected", "false");
        });
        tab.classList.add("active");
        tab.setAttribute("aria-selected", "true");
        document.querySelectorAll(".tab-content").forEach((c) => (c.style.display = "none"));
        document.getElementById(tabId).style.display = "block";
      });
    });
  }

  function toggleSidebar(id) {
    const el = document.getElementById(id);
    el.classList.toggle("collapsed");
  }

  function attachEventHandlers() {
    document.getElementById("newSongBtn").addEventListener("click", createNewSong);
    document.getElementById("duplicateSongBtn").addEventListener("click", duplicateCurrentSong);
    document.getElementById("deleteSongBtn").addEventListener("click", deleteCurrentSong);
    document.getElementById("saveSongToArchiveBtn").addEventListener("click", saveSongToArchive);
    document.getElementById("renameSongBtn").addEventListener("click", renameCurrentSong);
    document.getElementById("removeFromProjectBtn").addEventListener("click", removeCurrentSongFromProject);
    document.getElementById("exportSongTxtBtn").addEventListener("click", exportCurrentSongAsTxt);

    document.getElementById("saveTemplateBtn").addEventListener("click", saveTemplate);
    document.getElementById("applyTemplateToSongBtn").addEventListener("click", applyTemplateToSong);
    document.getElementById("insertSectionBtn").addEventListener("click", addSectionName);
    document.getElementById("addSectionBtn").addEventListener("click", addSectionSidebar);

    document.getElementById("saveProfileBtn").addEventListener("click", saveProfile);
    document.getElementById("exportProfilesBtn").addEventListener("click", exportProfilesAsJSON);
    document.getElementById("importProfilesBtn").addEventListener("click", () => {
      document.getElementById("importProfilesFile").click();
    });
    document.getElementById("importProfilesFile").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file) importProfilesFromFile(file);
      e.target.value = "";
    });

    document.getElementById("generateRandomBtn").addEventListener("click", generateRandomGenres);
    document.getElementById("insertGenresIntoSongBtn").addEventListener("click", () => {
      insertTextIntoSongEditor(document.getElementById("genresInput").value + "\n");
    });

    document.getElementById("refreshPreviewBtn").addEventListener("click", () => {
      updateCurrentSongFromInputs();
      renderPreview();
    });

    document.getElementById("themeSelect").addEventListener("change", (e) => {
      appState.settings.theme = e.target.value;
      SharedUI.applyTheme(appState.settings.theme);
      document.body.setAttribute("data-theme", appState.settings.theme);
      saveState();
    });
    document.getElementById("fontSizeSelect").addEventListener("change", (e) => {
      appState.settings.fontSize = e.target.value;
      applySettingsToDOM();
      saveState();
    });

    document.getElementById("toggleLeftSidebarBtn").addEventListener("click", () => toggleSidebar("leftSidebar"));
    document.getElementById("toggleRightSidebarBtn").addEventListener("click", () => toggleSidebar("rightSidebar"));

    document.getElementById("backupExportBtn").addEventListener("click", exportBackup);
    document.getElementById("backupImportBtn").addEventListener("click", () => {
      document.getElementById("backupImportFile").click();
    });
    document.getElementById("backupImportFile").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file) importBackup(file);
      e.target.value = "";
    });

    const debouncedUpdate = debounce(updateCurrentSongFromInputs, 300);
    ["songTitleInput", "songEditor", "genresInput", "tagsInput", "coverIdeasInput"].forEach((id) => {
      const el = document.getElementById(id);
      el.addEventListener("input", debouncedUpdate);
    });

    window.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
        e.preventDefault();
        updateCurrentSongFromInputs();
        saveState();
        showToast("Song gespeichert (Strg+S).", false);
      }
    });

    window.addEventListener("beforeunload", () => {
      try {
        updateCurrentSongFromInputs();
        saveState();
      } catch (err) {}
    });

    setupColumnResizers();
    setupZoomHandlers();
  }

  function setupColumnResizers() {
    const main = document.querySelector(".main");
    const col1 = document.querySelector(".col-1");
    const col2 = document.querySelector(".col-2");
    const col3 = document.querySelector(".col-3");
    const resizers = document.querySelectorAll(".col-resizer");

    let isDragging = false;
    let currentResizer = null;
    let startX = 0;
    let startWidths = null;

    function onMouseDown(e) {
      isDragging = true;
      currentResizer = e.target;
      startX = e.clientX;
      startWidths = {
        col1: col1.getBoundingClientRect().width,
        col2: col2.getBoundingClientRect().width,
        col3: col3.getBoundingClientRect().width
      };
      document.body.style.cursor = "col-resize";
      e.preventDefault();
    }

    function onMouseMove(e) {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const total = startWidths.col1 + startWidths.col2 + startWidths.col3;
      if (currentResizer.dataset.resizer === "1") {
        let newCol1 = startWidths.col1 + dx;
        let newCol2 = startWidths.col2 - dx;
        newCol1 = Math.max(150, Math.min(newCol1, total - 300));
        newCol2 = Math.max(150, Math.min(newCol2, total - newCol1 - 150));
        col1.style.flex = "0 0 " + newCol1 + "px";
        col2.style.flex = "0 0 " + newCol2 + "px";
        col3.style.flex = "1 1 0";
      } else if (currentResizer.dataset.resizer === "2") {
        let newCol2 = startWidths.col2 + dx;
        let newCol3 = startWidths.col3 - dx;
        newCol2 = Math.max(150, Math.min(newCol2, total - 300));
        newCol3 = Math.max(150, Math.min(newCol3, total - (startWidths.col1) - newCol2));
        col2.style.flex = "0 0 " + newCol2 + "px";
        col3.style.flex = "0 0 " + newCol3 + "px";
        col1.style.flex = "0 0 " + startWidths.col1 + "px";
      }
    }

    function onMouseUp() {
      if (!isDragging) return;
      isDragging = false;
      currentResizer = null;
      document.body.style.cursor = "default";
    }

    resizers.forEach((r) => {
      r.addEventListener("mousedown", onMouseDown);
    });

    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
  }

  function enhanceFieldGroups() {
    const groups = document.querySelectorAll("[data-field-group]");
    groups.forEach((group, index) => {
      if (group.dataset.enhanced === "1") return;
      const children = Array.from(group.children);
      const label = children.find((c) => c.classList && c.classList.contains("field-label"));
      if (!label) return;
      let content = children.find((c) => c.classList && c.classList.contains("field-content"));
      if (!content) {
        content = document.createElement("div");
        content.className = "field-content";
        children.forEach((child) => {
          if (child !== label) {
            content.appendChild(child);
          }
        });
        group.appendChild(content);
      }
      const actions = document.createElement("span");
      actions.className = "field-actions";
      const btnMax = document.createElement("button");
      btnMax.type = "button";
      btnMax.className = "field-action-btn";
      btnMax.textContent = "‚§¢";
      btnMax.title = "Maximieren";
      btnMax.addEventListener("click", () => {
        group.classList.toggle("maximized");
      });
      const btnMin = document.createElement("button");
      btnMin.type = "button";
      btnMin.className = "field-action-btn";
      btnMin.textContent = "‚ñÅ";
      btnMin.title = "Minimieren";
      btnMin.addEventListener("click", () => {
        group.classList.toggle("minimized");
      });
      const btnOff = document.createElement("button");
      btnOff.type = "button";
      btnOff.className = "field-action-btn";
      btnOff.textContent = "‚èª";
      btnOff.title = "Deaktivieren/Aktivieren";
      btnOff.addEventListener("click", () => {
        const disabled = group.classList.toggle("disabled");
        group.querySelectorAll("input, textarea, select, button").forEach((el) => {
          if (el.classList.contains("field-action-btn")) return;
          el.disabled = disabled;
        });
      });
      actions.appendChild(btnMax);
      actions.appendChild(btnMin);
      actions.appendChild(btnOff);
      label.appendChild(actions);
      group.dataset.enhanced = "1";
    });
  }

  function setupZoomHandlers() {
    window.addEventListener("wheel", (e) => {
      if (!e.ctrlKey) return;
      e.preventDefault();
      const delta = e.deltaY < 0 ? 0.1 : -0.1;
      const target = e.target;
      if (target.closest(".text-zoom-area") || target.tagName === "TEXTAREA" || target.tagName === "INPUT") {
        let tz = appState.settings.textZoom || 1;
        tz += delta;
        tz = Math.min(2, Math.max(0.6, tz));
        appState.settings.textZoom = tz;
        document.documentElement.style.setProperty("--text-zoom", tz);
      } else {
        let uz = appState.settings.uiZoom || 1;
        uz += delta;
        uz = Math.min(1.6, Math.max(0.7, uz));
        appState.settings.uiZoom = uz;
        document.documentElement.style.setProperty("--ui-zoom", uz);
      }
      saveState();
    }, { passive: false });
  }

  function setupAutosaveClock() {
    setupAutosave();
    setInterval(updateClock, 1000);
    updateClock();
  }

  function init() {
    loadState();
    ensureCurrentSong();
    attachEventHandlers();
    setupTabs();
    renderAll();
    setupAutosaveClock();
    setStatus("Bereit ‚Äì du kannst loslegen.");
    logEvent("App gestartet.");
  }

  document.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
